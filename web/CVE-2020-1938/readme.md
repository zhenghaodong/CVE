# CVE-2020-1938 Tomcat-AJP协议漏洞分析复现

## 背景

### 环境

Tomcat：Tomcat是一个基于组件的服务器，它的构成组件都是可配置的。从结构上来看，最外层的是Catalina servlet容器，其他组件按照一定的格式要求配置在这个顶层容器中。tomcat实现了对Servlet和JavaServer Page（JSP）的支持，由于其本身也内含了HTTP服务器，因此也可以视作单独的Web服务器。

漏洞信息：CVE-2020-1938是文件包含漏洞，攻击者可利用该漏洞读取或包含 Tomcat 上所有 webapp 目录下的任意文件，如：webapp 配置文件、源代码等。该漏洞影响的版本：

- Apache Tomcat 9.x < 9.0.31
- Apache Tomcat 8.x < 8.5.51
- Apache Tomcat 7.x < 7.0.100
- Apache Tomcat 6.x

### AJP协议

AJP协议全称为 Apache JServ Protocol，为一个二进制tcp传输协议。与本漏洞相关的是AJP协议的`AJP13_FORWARD_REQUEST` 请求格式。Apache Tomcat Server通过connector组件来与客户端建立连接。connector组件负责接受客户端请求并把Tomcat服务端的响应发送给用户。AJP连接器通过8009端口来提供服务。

## 复现细节

### 配置

**tomcat**：

![](https://github.com/zhenghaodong/picture/raw/master/3.PNG)

### 效果

![](https://github.com/zhenghaodong/picture/raw/master/4.PNG)

### 原理

#### Tomcat内部请求流程

首先先明确tomcat的**体系结构**：

![](https://github.com/zhenghaodong/picture/raw/master/10.PNG)

Connecter组件负责在某个指定的端口上侦听客户请求，接收浏览器的发过来的 tcp 连接请求，创建一个 Request 和 Response 对象分别用于和请求端交换数据。Tomcat中有两个经典的Connector，一个直接侦听来自Browser的HTTP请求，另外一个来自其他的WebServer请求。Cotote HTTP/1.1 Connector在端口8080处侦听来自客户Browser的HTTP请求，Coyote JK2 Connector在端口8009处侦听其他Web Server的Servlet/JSP请求。Connector中的Processor用于封装Request，Adapter用于将封装好的Request交给Container。

Container负责处理Connecter发送过来的请求。Container有四个组件：Engine、Host、Context、Wrapper。**Engine** 容器定义了一些基本的关联关系；**Host**容器负责运行多个应用并对不同的应用进行标识；**Context**容器代表Servlet的Context，Context负责管理Servlet实例(Servlet 实例在 Context 中是以 Wrapper 出现的)；**Wrapper**容器代表一个Servlet，它负责管理一个 Servlet，包括的 Servlet 的装载、初始化、执行以及资源回收(Wrapper 是最底层的容器)。

**内部处理请求过程**：

* 用户点击网页内容，请求被发送到本机端口8080，被Connector获得；
* Connector把该请求交给Container中的Engine来处理，并等待Engine的回应；
* Engine获得请求localhost/test/index.jsp，匹配所有的虚拟主机Host；
* Engine匹配到名为localhost的Host，名为localhost的Host获得请求/test/index.jsp，匹配它所拥有的所有的Context。Host匹配到路径为/test的Context；
* path="/test"的Context获得请求/index.jsp，在它的mapping table中寻找出对应的Servlet，匹配到pattern为*jsp的Servlet，对应于JspServlet类，匹配不到指定Servlet的请求对应DefaultServlet类；
* Wrapper构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet()或doPost()，执行业务逻辑、数据存储等程序；
* Context把执行完之后的HttpServletResponse对象返回给Host；
* Host把HttpServletResponse对象返回给Engine；
* Engine把HttpServletResponse对象返回Connector；
* Connector把HttpServletResponse对象返回给客户Browser。

#### tomcat漏洞代码分析

漏洞主要是由AJP协议8009端口触发。

对于任意文件读取部分，请求并不是jsp因此走的是DefaultServlet，而命令执行走的是JspServlet。

对于任意文件读取，请求首先抵达Connector组件，Connector使用AjpProcessor解析Socket并将解析内容封装在request中：

![](https://github.com/zhenghaodong/picture/raw/master/5.PNG)

该函数首先判断`SC_A_REQ_ATTRIBUTESC_A_REQ_ATTRIBUTE`，如果符合使用的AJP属性，则进入该case。SC_A_REQ_REMOTE_PORT对应的是AJP_REMOTE_PORT，这里指的是对远程端口的转发，Ajp13并没有转发远程端口，但是接受转发的数据作为远程端口。

因此利用思路就是对AJP13转发的数据进行封装：

* javax.servlet.include.request_uri 
* javax.servlet.include.path_info 
* javax.servlet.include.servlet_path

**任意文件读取**：

org.apache.catalina.servlets.DefaultServlet#serveResource()方法会接收请求

![](https://github.com/zhenghaodong/picture/raw/master/6.PNG)

首先doGet获取请求后跳转到serveResource函数。

![](https://github.com/zhenghaodong/picture/raw/master/7.PNG)

serveResouce通过getRelativePath函数获取到请求的路径，并将路径path作为参数，调用getResource函数获取资源。

getRelativePath()函数中涉及到三个重要参数：

```java
static final String INCLUDE_REQUEST_URI = "javax.servlet.include.request_uri";
static final String INCLUDE_PATH_INFO = "javax.servlet.include.path_info";
static final String INCLUDE_SERVLET_PATH = "javax.servlet.include.servlet_path";
```

因此利用脚本可以自己声明三个参数然后代入getRelativePath()方法，从而控制该三个参数。

![](https://github.com/zhenghaodong/picture/raw/master/8.PNG)

**命令执行**：处理jsp请求的uri时，会调用org.apache.jasper.servlet.JspServlet#service()函数。

![](https://github.com/zhenghaodong/picture/raw/master/9.PNG)

pathInfo会被附加到jspUri后面，程序会将jspUri传递给serviceJspFile()函数来处理。当用户控制服务器上的jsp文件时就会造成rce。

[本CVE的exp](https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi/blob/master/CNVD-2020-10487-Tomcat-Ajp-lfi.py)。
